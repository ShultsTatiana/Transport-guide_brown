## Transport guide brown/Транспортный справочник, часть E
Cистема хранения транспортных маршрутов и обработки запросов к ней <br/>
Всего 5 частей, в которых будет производиться расширение проекта <br/>

Часть E. Добавить в транспортный справочник функционал маршрутизации,  <br/>
реализованный с помощью предоставленных библиотек.

### Ввод вывод в формате JSON
* запросы самого верхнего уровня заключены в словарь `{}`
* ключ словаря заключается в кавычки`""`
* ключ и значение разделяются двоеточием `:`
* значениями могут быть:
	- строки - заключаются в ковычки`""`
	- целые числа
	- вещественные числа <br/>
		грантируется, что вещественные числа не задаются в экспоненциальной записи,
		т.е. обязательно имеют целую часть и, возможно, дробную часть через десятичную точку. <br/>
	- словари, в том числе пустые - заключены в фигугрые скобки `{}`
	- массивы, содержащие значения - заключены в квадратные скобки `[]`
* пары ключ-значение разделяются запятыми `,` и преносом строки
* меджу всеми сиволами (`[]{},:`) может стоять произвольное количество пробельных символов 
* в словаре верхнего уровня два типа ключей (запросов) к базе: `base_requests` и `stat_requests`
* Ключи словарей могут располагаться в произвольном порядке.

### Формат ввода
в формате JSON

#### Запросы типа`routing_settings`
- запрос `routing_settings` в качестве значения примает словарь с двумя ключами - `"base_requests": {}`
1. `"bus_wait_time"` - время ожидания автобуса на остановке (в минутах) - **целое число от 1 до 1000** <br/>
Считайте, что когда бы человек ни пришёл на остановку и какой бы ни была эта остановка, 
он будет ждать любой автобус в точности указанное количество минут.
2. `"bus_velocity"` - скорость автобуса (в **км/ч**) - **вещественное число от 1 до 1000** <br/>
Считайте, что скорость любого автобуса постоянна и в точности равна указанному числу. 
Время стоянки на остановках не учитывается, время разгона и торможения — тоже. 
##### Пример
	"routing_settings": {
		"bus_wait_time": 6,
		"bus_velocity": 40`
	}
На маршруте человек может использовать несколько автобусов,  <br/>
один автобус - несколько раз - если на некоторых участках он делает большой крюк и проще срезать на другом автобусе. <br/>
 <br/>
Маршрут должен быть наиболее оптимален по времени.  <br/>
Если маршрутов с минимально возможным суммарным временем несколько, допускается вывести любой из них:  <br/>
тестирующая система проверяет лишь совпадение времени маршрута с оптимальным и корректность самого маршрута.
 <br/>
При прохождении маршрута время расходуется на два типа активностей: <br/>
* Ожидание автобуса. Всегда длится **bus_wait_time** минут. <br/>
* Поездка на автобусе. Всегда длится ровно такое количество времени, 
которое требуется для преодоления данного расстояния со скоростью **bus_velocity**. 
Расстояние между остановками вычисляется по дорогам, то есть с помощью **road_distances**. <br/>
 <br/>
Ходить пешком, выпрыгивать из автобуса между остановками и использовать другие виды транспорта запрещается.  <br/>
На конечных остановках все автобусы высаживают пассажиров и уезжают в парк.  <br/>
Даже если человек едет на кольцевом ("is_roundtrip": true) маршруте и хочет проехать мимо конечной, 
он будет вынужден выйти и подождать тот же самый автобус ровно bus_wait_time минут.  <br/>
Этот и другие случаи разобраны в примерах.

#### Запросы на заполнение базы `base_requests`
- запрос `base_requests` в качестве значения примает массив словарей - `"base_requests": [ {},{} ]
- словари в этом массиве делятся на два типа `"type"` запросов: `"Stop"` и `"Bus"`
1. `"type": "Stop",` - Запрос типа `"Stop"` <br/>
1.1. `"type": "Stop",` - тип запроса, значение - **строка** <br/>
1.2. `"name": "Biryulyovo Passazhirskaya",` - название остановки, значение - **строка** <br/>
1.3. `"road_distances": {` - дорожное расстояние, **словарь** с расстояниями до перечисленных остановок <br/>
	a) `"Marushkino": 3900,` - ключ - название остановки, значение - расстояние до неё в метрах - **целое число** <br/>
	b) может быть пуст, с одним или несколькими парами остановка-расстояние <br/>
1.4. `"longitude": 37.659164,` - широта, значение - **вещественное число** <br/>
1.5. `"latitude": 55.580999` - долгота, значение - **вещественное число** <br/>
2. `"type": "Bus",` - Запрос типа `"Bus"` <br/>
2.1. `"type": "Bus",` - тип запроса, значение - **строка** <br/>
2.2. `"name": "828",` - название остановки, значение - **строка** <br/>
2.3. `"stops": {` - маршрут - массив остановок на данном маршруте <br/>
	a) `"Biryulyovo Zapadnoye",` - значение - название остановки - **строка** <br/>
	b) может быть пуст, с одним или несколькими парами остановка-расстояние <br/>
2.4. `"is_roundtrip": true` - тип маршрута, значение - bool <br/>
	a) `true` - кольцевой маршрут <br/>
	b) `false` - маршрут туда-обратно - НЕ кольцевой <br/>

#### Запросы к базе `stat_requests`
##### общие (обязательные) ключи для запросов всех типов
- `"id": 65100610` - номер запроса, значение - **целое число от 0 до 2147483647**
- `"type": "Stop",` - тип запроса - `"Stop"`, `"Bus"`, `"Route"` - значение - **строка**
##### дополнительные ключи, обязательные для каждого из типов запросов
1. `"type": "Stop",` - запрос по остановке
- `"name": "751",` - название остановки, значение - **строка**
2. `"type": "Bus",` - запрос по автобусу
- `"name": "751",` - название автобуса, значение - **строка**
3. `"type": "Route",` - запрос на построение маршрута между двумя остановками. 
- `"from": "Biryulyovo Zapadnoye",` - остановка, в которой нужно начать маршрут - ключ и значение - **строка**
- `"to": "Universam"` - остановка, в которой нужно закончить маршрут - ключ и значение - **строка** <br/>
Оба значения — названия существующих в базе остановок **(однако, возможно, не принадлежащих ни одному автобусному маршруту)**.
##### Пример `"type": "Route"`
	{
		"type": "Route", 
		"from": "Biryulyovo Zapadnoye",
		"to": "Universam",
		"id": 4
	}
	//Данный запрос означает построение маршрута от остановки Biryulyovo Zapadnoye до остановки Universam
### Формат вывода
в формате JSON
- создать массив `[]` словарей `{}` - ответов на запросы
- ответы на запросы будут двух видов `Stop` и `Bus`
#### Stop
Словарь запроса `"Stop"` содержит следующие пары ключ-значение
1. `"request_id": 1965312327,` - `"id"` запроса, значение - **целое число** указанное ранее в запросе `stat_requests` <br/>
2. В зависимости от результата, добавить в словарь (либо-либо): <br/>
	2.1. `"buses": [` - массив автобусов, проходящих через остановку запроса типа `Stop` <br/>
		-- массив содержит отсортированные в лексико-графическом порядке **строки** - названия автобусов <br/>
		-- массив может быть пуст (эквивалентно `Stop X: no buses`) <br/>
	2.2. `"error_message": "not found"` - Если остановка`X` не найдена 
#### Bus
Словарь запроса `"Bus"` содержит следующие пары ключ-значение
1. `"request_id": 1965312327,` - `"id"` запроса, значение - **целое число** указанное ранее в запросе `stat_requests` <br/>
2. В зависимости от результата, добавить в словарь (либо-либо): <br/>
	2.1. словарь, состоящий из следующих пар ключ-значение: <br/>
		-- `"route_length": 27600,` -  <br/>
		-- `"request_id": 519139350,` -  <br/>
		-- `"curvature": 1.31808,` -  <br/>
		-- `"stop_count": 5,` -  <br/>
	2.2. `"error_message": "not found"` - Если автобус `X` не найден 
#### Route
1. Словарь запроса `"Route"` содержит следующие пары ключ-значение в случае если маршрут построить возможно <br/>
	1.1. `"request_id": 1965312327,` - `"id"` запроса, значение - **целое число** указанное ранее в запросе `stat_requests` <br/>
	1.2. `"total_time": <суммарное время>,` - суммарное время в минутах, требуемое для прохождения маршрута - **вещественное число** <br/>
	1.3. `"items": [ <элементы маршрута> ]` - список элементов маршрута, каждый из которых описывает непрерывную активность пассажира, требующую временных затрат. - **массив** <br/>
Элементы маршрута бывают двух типов `"Wait"` и `"Bus"` - словари - ключи - **строки**. <br/>
	- `Wait` - подождать нужное количество минут (в нашем случае — всегда `bus_wait_time`) на указанной остановке <br/>
	-- `"type": "Wait",` - тип маршрута ожидание - **строка**<br/>
	-- `"stop_name": "Biryulyovo",` - имя остановки - **строка**<br/>
	-- `"time": 6` - количество минут ожидания - **целое число от 1 до 1000**<br/>
	- `Bus` - проехать `span_count` остановок (перегонов между остановками) на автобусе `bus`, потратив указанное количество минут<br/>
	-- `"type": "Bus",` - тип маршрута поездка на автобусе - **строка**<br/>
	-- `"bus": "297",` - имя автобуса - **строка**<br/>
	-- `"span_count": 2,` - количество перегонов между остановками, кот. нужно проехать - **целое число от 1 до 100**<br/>
	-- `"time": 5.235` - количество минут ожидания - **вещественное число**<br/>
2. И если НЕ возможно построить маршрут <br/>
	2.1. `"request_id": 1965312327,` - `"id"` запроса, значение - **целое число** указанное ранее в запросе `stat_requests` <br/>
	2.2. `"error_message": "not found"` - сообщение об ошибке - Не найден - **строка** <br/>

#### Дополнение к выводу запроса
- Если автобус `X` не найден - `"error_message": "not found"`.
- Если остановка`X` не найдена - `"error_message": "not found"`.
- Если остановка`X` существует в базе, но через неё не проходят автобусы - `[]`.
- Дубли остановок не допускаются, названия должны быть отсортированы в алфавитном порядке. <br/>
- Величину расстояния (а также другие **вещественные числа** в последующих частях задачи) 
**выводите с 6 значащими цифрами**, то есть предваряя модификатором `setprecision(6)`. 
При этом ваши **значения сравниваются** с верными не посимвольно, а **с относительной погрешностью 0,0001**.
#### Ввод и вывод производится в формате JSON
- Ключи словарей могут располагаться в произвольном порядке.  <br/>
- Форматирование (пробельные символы вокруг скобок, запятых и двоеточий)
 не имеет значения как во **входном**, так и в **выходном** JSON. <br/>


### Ограничения
- 3 секунды на обработку всех запросов.<br/>
В реальном маршрутизаторе время на предварительную подготовку данных вполне могло бы занимать минуты, что позволило бы увеличить это ограничение.
- 512 МБ ограничение по памяти.
- Количество остановок, и количество автобусов не превышает 100. 
- **_D#_** являются целыми положительными числами, **_D#_ <= 10^6**.
- Не более 25 символов в названии автобуса или остановки. 
Допустимые символы — латинские буквы, цифры и пробелы. 
Все названия непусты, не могут начинаться на пробелы или заканчиваться ими.
- Географическое расстояние - вещественное число.
- **_L_** — дорожное расстояние - вещественное число, **_L_ >= 1**.
- При вычислении географического расстояния (расстояния между двумя точками на земной поверхности) считайте:
  1. число `π = 3.1415926535`, <br/>
  2. радиус Земли — `6371 км`. <br/>

### Уточнения
* Гарантируется, что остановка определена ТОЛЬКО В ОДНОМ запросе `Stop NAME`.
* Гарантируется, что каждая из **остановок** маршрута определена в некотором запросе Stop.
* Гарантируется, что сам **маршрут** NAME определён ТОЛЬКО В ОДНОМ запросе Bus.
* Гарантируется, что каждая из остановок **stop#** определена в некотором запросе Stop.
* Гарантируется, что в рамках одного запроса **Stop** все _stop#_ различны.
* Гарантируется, что **_D#_** >= длинны прямого маршрута по оверхности земли.
* Гарантируется, что для любых двух соседних остановок любого маршрута так или иначе задано расстояние по дорогам. 
* Обратите внимание, что расстояние от остановки A до остановки B может быть не равно расстоянию от B до A!

## Реализация graph
В отличие от парсера JSON в предыдущей версии задачи, эти библиотеки не нуждаются в модификации. <br/>
С другой стороны, вы имеете право не использовать их вовсе или модифицировать произвольным образом. <br/>
* `graph.h` — класс, реализующий взвешенный ориентированный граф.
* `router.h` — класс, реализующий поиск кратчайшего пути во взвешенном ориентированном графе. <br/>

Моделируя ситуации из реальной жизни разработчиков, обе эти библиотеки предоставляются без документации, но с самодокументируемым кодом: 
интерфейсы представленных классов легко читаются по заголовкам публичных методов. <br/>

### Информация о классах:
1. Граф <br/>
1.1. **Вершины и рёбра графа** нумеруются автоинкрементно беззнаковыми целыми числами, хранящимися в типах VertexId и EdgeId: <br/>
-- вершины нумеруются от 0 до количества вершин минус один в соответствии с пользовательской логикой,  <br/>
-- номер очередного ребра выдаётся методом AddEdge, равен нулю для первого вызова метода и при каждом следующем вызове увеличивается на единицу. <br/>
1.2. Память, необходимая для хранения графа, линейна относительно суммы количеств вершин и рёбер. <br/>
1.3. Конструктор и деструктор графа имеют линейную сложность, а остальные методы константны или амортизированно константны. <br/>
2. Маршрутизатор <br/>
2.1. **Маршрутизатор** (класс Router) требует квадратичного относительно количества вершин объёма памяти, не считая памяти, требуемой для хранения кэша маршрутов. <br/>
2.2. Конструктор маршрутизатора имеет сложность O(V³+E), где V — количество вершин графа, E — количество рёбер. <br/>
2.3. Маршрутизатор не работает с графами, имеющими рёбра отрицательного веса. <br/>
2.4. Построение маршрута на готовом маршрутизаторе линейно относительно количества рёбер в маршруте. <br/> 
Таким образом, основная нагрузка построения оптимальных путей ложится на конструктор.

### Вам необходимо:
1. самостоятельно разобраться с понятиями графов и путями в них;
2. придумать, как по транспортному справочнику построить граф, 
путь наименьшего веса в котором соответствует оптимальному маршруту на автобусах, 
предварительно определившись, что в этом графе будет являться вершинами, а что — рёбрами;
3. написать код построения графа и описания маршрута по пути, полученному от маршрутизатора.